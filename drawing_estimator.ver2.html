<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exterior Planner - 外構積算ツール (Chrome対応統合版)</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Excel Reading Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- PDF Generation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cad: {
                            bg: '#1e1e1e',
                            panel: '#252526',
                            border: '#3e3e42',
                            accent: '#007fd4',
                            text: '#cccccc'
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; }
        .tool-btn.active { background-color: #007fd4; color: white; }
        .nav-btn.active { border-bottom: 2px solid #007fd4; color: white; }
        .custom-scroll::-webkit-scrollbar { width: 8px; }
        .custom-scroll::-webkit-scrollbar-track { background: #252526; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #3e3e42; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #505050; }
        
        /* Loading Overlay */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); color: white; display: none;
            justify-content: center; align-items: center; z-index: 9999; flex-direction: column;
        }
        
        /* Accordion transition */
        .accordion-content { transition: max-height 0.3s ease-out; max-height: 0; overflow: hidden; }
        .accordion-content.open { max-height: 500px; overflow-y: auto; }

        /* Table Styles */
        .master-table th { background-color: #333; color: #fff; padding: 8px; text-align: left; font-size: 0.85rem; white-space: nowrap; }
        .master-table td { border-bottom: 1px solid #3e3e42; padding: 8px; font-size: 0.85rem; vertical-align: middle; }
        .master-table tr:hover { background-color: #2a2d2e; }
    </style>
</head>
<body class="bg-cad-bg text-cad-text h-screen flex flex-col">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="text-xl mb-2"><i class="fas fa-spinner fa-spin mr-2"></i>処理中...</div>
        <div id="loaderStatus" class="text-sm text-gray-300"></div>
    </div>

    <!-- Header -->
    <header class="bg-cad-panel border-b border-cad-border h-12 flex items-center justify-between px-4 shrink-0 z-10">
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2 mr-4">
                <i class="fas fa-drafting-compass text-cad-accent"></i>
                <span class="font-bold text-white">Exterior Planner</span>
            </div>
            
            <!-- Navigation -->
            <div class="flex h-full">
                <button class="nav-btn active h-full px-4 text-sm font-medium text-gray-400 hover:text-white transition" data-view="planner">
                    <i class="fas fa-pencil-ruler mr-1"></i> 図面・積算
                </button>
                <button class="nav-btn h-full px-4 text-sm font-medium text-gray-400 hover:text-white transition" data-view="master">
                    <i class="fas fa-database mr-1"></i> 部材マスタ管理
                </button>
            </div>
        </div>

        <!-- Planner Actions (Visible only in Planner View) -->
        <div id="plannerActions" class="flex gap-2 items-center">
            <div class="flex bg-gray-700 rounded mr-2">
                <label class="cursor-pointer hover:bg-gray-600 px-3 py-1 rounded-l text-sm transition text-white border-r border-gray-600" title="図面読込">
                    <i class="fas fa-folder-open mr-1"></i> 読込
                    <input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" class="hidden">
                </label>
                <button id="rotateLeftBtn" class="hover:bg-gray-600 px-2 py-1 text-white border-r border-gray-600" title="左90度回転">
                    <i class="fas fa-undo"></i>
                </button>
                <button id="rotateRightBtn" class="hover:bg-gray-600 px-2 py-1 rounded-r text-white" title="右90度回転">
                    <i class="fas fa-redo"></i>
                </button>
            </div>

            <div class="h-6 w-px bg-gray-600 mx-1"></div>
            
            <button id="saveImgBtn" class="bg-blue-800 hover:bg-blue-700 px-3 py-1 rounded text-sm text-white transition" title="画像として保存">
                <i class="fas fa-image mr-1"></i> PNG
            </button>
            <button id="savePdfBtn" class="bg-red-800 hover:bg-red-700 px-3 py-1 rounded text-sm text-white transition" title="PDFとして保存">
                <i class="fas fa-file-pdf mr-1"></i> PDF
            </button>
            <div class="h-6 w-px bg-gray-600 mx-1"></div>
            
            <!-- CSV Option (New) -->
            <label class="flex items-center gap-1 text-xs text-gray-300 mr-2 cursor-pointer hover:text-white">
                <input type="checkbox" id="csvIncludeDetails" class="rounded bg-gray-700 border-gray-600">
                詳細寸法を含める
            </label>
            <button id="exportBtn" class="bg-green-700 hover:bg-green-600 px-3 py-1 rounded text-sm text-white transition">
                <i class="fas fa-file-csv mr-1"></i> CSV出力
            </button>
        </div>
    </header>

    <!-- VIEW: PLANNER (Canvas & Tools) -->
    <div id="view-planner" class="flex-1 flex overflow-hidden">
        
        <!-- Left Toolbar -->
        <div class="w-16 bg-cad-panel border-r border-cad-border flex flex-col items-center py-4 gap-4 shrink-0 z-10">
            <button class="tool-btn w-10 h-10 rounded flex items-center justify-center hover:bg-gray-700 active" data-tool="select" title="選択・移動">
                <i class="fas fa-mouse-pointer"></i>
            </button>
            <div class="w-8 h-px bg-cad-border"></div>
            <button class="tool-btn w-10 h-10 rounded flex items-center justify-center hover:bg-gray-700" data-tool="scale" title="スケール設定 (2点間距離)">
                <i class="fas fa-ruler-horizontal"></i>
            </button>
            <div class="w-8 h-px bg-cad-border"></div>
            <button class="tool-btn w-10 h-10 rounded flex items-center justify-center hover:bg-gray-700" data-tool="line" title="距離計測 (連続線)">
                <i class="fas fa-pen-nib"></i>
            </button>
            <button class="tool-btn w-10 h-10 rounded flex items-center justify-center hover:bg-gray-700" data-tool="area" title="面積計測 (多角形)">
                <i class="fas fa-draw-polygon"></i>
            </button>
            <button class="tool-btn w-10 h-10 rounded flex items-center justify-center hover:bg-gray-700" data-tool="count" title="個数カウント">
                <i class="fas fa-map-marker-alt"></i>
            </button>
        </div>

        <!-- Sub Sidebar (Settings) -->
        <div class="w-64 bg-cad-panel border-r border-cad-border flex flex-col shrink-0 z-10 custom-scroll overflow-y-auto">
            <div class="p-4 border-b border-cad-border">
                <h3 class="text-xs font-bold text-gray-400 uppercase mb-2">設定 & プロパティ</h3>
                
                <!-- Status Info -->
                <div class="mb-4 text-xs bg-gray-800 p-2 rounded">
                    <div class="flex justify-between mb-1">
                        <span>スケール:</span>
                        <span id="scaleStatus" class="text-yellow-500 font-mono">未設定</span>
                    </div>
                    <div class="flex flex-col gap-2 mt-2">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="showLabels" class="rounded bg-gray-700 border-gray-600" checked>
                            <label for="showLabels" class="cursor-pointer">ラベル・寸法表示</label>
                        </div>
                        
                        <!-- Font Size Slider (New) -->
                        <div class="flex flex-col gap-1">
                            <div class="flex justify-between">
                                <label for="globalFontSize" class="cursor-pointer">文字サイズ</label>
                                <span id="fontSizeDisplay" class="font-mono text-gray-400">14px</span>
                            </div>
                            <input type="range" id="globalFontSize" min="8" max="48" value="14" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>

                <!-- Material Settings (Hidden for Select/Scale) -->
                <div id="materialSettings">
                    <label class="block text-xs mb-1 text-gray-400">メイン部材選択 (マスタ参照)</label>
                    <select id="presetSelect" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm mb-3 text-white">
                        <!-- Populated by JS -->
                    </select>

                    <label class="block text-xs mb-1 text-gray-400">表示名称</label>
                    <input type="text" id="itemName" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm mb-3 text-white">

                    <!-- Unit Price Hidden from UI as requested, kept in logic -->
                    <input type="hidden" id="itemPrice"> 
                    
                    <div class="flex gap-2 mb-3">
                        <div class="flex-1">
                            <label class="block text-xs mb-1 text-gray-400">段数・個数 (整数)</label>
                            <input type="number" id="itemMultiplier" class="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm text-white" value="1" min="1" step="1">
                            <p class="text-[10px] text-gray-500">※寸法でなく単価に反映</p>
                        </div>
                         <div class="flex-1">
                             <label class="block text-xs mb-1 text-gray-400">サイズ/太さ</label>
                             <input type="range" id="lineWidth" min="1" max="10" value="2" class="w-full h-8 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <label class="block text-xs mb-1 text-gray-400">描画色</label>
                    <div class="flex gap-2 mb-3">
                        <input type="color" id="itemColor" class="h-8 w-12 bg-transparent border-none cursor-pointer">
                    </div>

                    <!-- Additional Items (Combo) -->
                    <div class="mb-3 pt-2 border-t border-cad-border">
                        <label class="block text-xs mb-1 text-blue-300"><i class="fas fa-plus-circle"></i> 同時計測する部材</label>
                        <select id="additionalItemSelect" class="w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-xs mb-2 text-white">
                            <option value="">+ 追加する部材を選択...</option>
                        </select>
                        <div id="additionalItemsList" class="space-y-1">
                            <!-- Added items appear here -->
                        </div>
                    </div>

                    <div id="subtractiveOption" class="hidden mb-3 pt-2 border-t border-cad-border">
                        <label class="flex items-center gap-2 text-red-400 cursor-pointer text-sm font-bold bg-gray-800 p-2 rounded border border-red-900 mb-2">
                            <input type="checkbox" id="isSubtractive">
                            <i class="fas fa-minus-circle"></i> 除外(中抜き)モード
                        </label>
                        
                        <button id="pickSubtractBtn" class="w-full bg-gray-700 hover:bg-gray-600 text-xs py-2 px-2 rounded border border-gray-500 text-gray-300 transition">
                            <i class="fas fa-crosshairs mr-1"></i> 既存図形を選択して除外
                        </button>
                        <p id="pickStatus" class="text-[10px] text-yellow-500 mt-1 hidden text-center animate-pulse">図形をクリックしてください...</p>
                    </div>
                </div>
                
                <div id="toolMessage" class="hidden text-gray-500 text-xs text-center py-4">
                    設定項目はありません
                </div>
            </div>
            
            <div class="p-4 text-xs text-gray-500">
                <p class="mb-2"><strong>操作方法:</strong></p>
                <ul class="list-disc pl-4 space-y-1">
                    <li>左クリック: 描画 / 点の追加</li>
                    <li>右クリック: 描画終了 / 閉じる</li>
                    <li>ホイール: ズーム</li>
                    <li>ホイール押し込み: パン（移動）</li>
                    <li>Delキー: 直前の点/選択削除</li>
                </ul>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 relative bg-[#111] overflow-hidden cursor-crosshair" id="canvasContainer">
            <div id="canvasOverlay" class="absolute top-4 left-4 pointer-events-none select-none text-white drop-shadow-md z-20">
                <h1 class="text-2xl font-bold opacity-50">Exterior Planner</h1>
                <p id="cursorPos" class="font-mono text-xs opacity-70">X: 0, Y: 0</p>
            </div>
            <canvas id="mainCanvas" class="absolute top-0 left-0"></canvas>
        </div>

        <!-- Right Sidebar (Estimation) -->
        <div class="w-80 bg-cad-panel border-l border-cad-border flex flex-col shrink-0 z-10">
            <div class="p-3 border-b border-cad-border bg-gray-800 flex justify-between items-center">
                <h3 class="font-bold text-sm text-white"><i class="fas fa-calculator mr-2"></i>積算リスト</h3>
                <span class="text-xs text-gray-400">クリックで詳細</span>
            </div>
            
            <div class="flex-1 overflow-y-auto custom-scroll p-2" id="estimationList">
                <div class="text-center text-gray-500 mt-10 text-sm">
                    計測データがありません
                </div>
            </div>

            <!-- Manual Entry Section -->
            <div class="p-3 border-t border-cad-border bg-gray-800">
                <label class="block text-xs font-bold text-yellow-500 mb-2">
                    <i class="fas fa-pen-to-square mr-1"></i> 付帯工事・その他 (手入力)
                </label>
                
                <div class="flex gap-2 mb-2">
                    <input type="text" id="manualItemName" placeholder="項目名" class="flex-1 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs text-white focus:border-cad-accent outline-none">
                    <input type="number" id="manualItemPrice" placeholder="金額" class="w-20 bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs text-white focus:border-cad-accent outline-none">
                    <button id="addManualItemBtn" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded text-xs transition font-bold tracking-wider">
                        追加
                    </button>
                </div>
                
                <div id="manualItemList" class="space-y-1 max-h-40 overflow-y-auto custom-scroll mb-1">
                    <!-- Manual items populated here -->
                </div>
            </div>

            <div class="p-4 bg-gray-800 border-t border-cad-border">
                <div class="flex justify-between items-end mb-1">
                    <span class="text-sm">合計概算金額</span>
                    <span class="text-2xl font-bold text-green-400" id="totalAmount">¥0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- VIEW: MASTER DATA (Management) -->
    <div id="view-master" class="flex-1 hidden bg-[#111] overflow-hidden flex-col p-6">
        <div class="max-w-6xl mx-auto w-full h-full flex flex-col">
            <div class="flex justify-between items-end mb-6">
                <div>
                    <h2 class="text-2xl font-bold text-white mb-2">部材・単価マスタ管理</h2>
                    <p class="text-gray-400 text-sm">図面作成で使用する部材の名称、参照商品名、単位、単価を管理します。<br>
                    <span class="text-yellow-500">※Excel取込形式：A列=部材名, B列=参照商品名(画像検索用), C列=単位(m/m2/基), D列=単価</span><br>
                    <span class="text-red-400 text-xs" id="dbStatusMsg"></span>
                    </p>
                </div>
                <div class="flex gap-2">
                    <button id="deleteAllBtn" class="bg-red-700 hover:bg-red-600 px-4 py-2 rounded text-white transition flex items-center gap-2 shadow-lg text-sm border border-red-500">
                        <i class="fas fa-trash-alt"></i> 全データ削除
                    </button>
                    <button id="restoreDefaultsBtn" class="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded text-white transition flex items-center gap-2 shadow-lg text-sm">
                        <i class="fas fa-undo"></i> 初期データ復元
                    </button>
                    <label class="cursor-pointer bg-green-700 hover:bg-green-600 px-4 py-2 rounded text-white transition flex items-center gap-2 shadow-lg text-sm">
                        <i class="fas fa-file-excel"></i> 単価表一括取込
                        <input type="file" id="priceListInput" accept=".csv, .xlsx, .xls" class="hidden">
                    </label>
                </div>
            </div>

            <!-- Add New Form -->
            <div class="bg-cad-panel p-4 rounded border border-cad-border mb-6 flex gap-4 items-end flex-wrap">
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-xs text-gray-400 mb-1">部材名称</label>
                    <input type="text" id="newMatName" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white" placeholder="例: メッシュフェンス T-8">
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-xs text-gray-400 mb-1">参照商品名 (画像検索用)</label>
                    <input type="text" id="newMatRef" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white" placeholder="例: ハイグリッドフェンスN8型">
                </div>
                <div class="w-24">
                    <label class="block text-xs text-gray-400 mb-1">単位</label>
                    <input type="text" id="newMatUnit" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white" placeholder="m / m2">
                </div>
                <div class="w-32">
                    <label class="block text-xs text-gray-400 mb-1">単価 (円)</label>
                    <input type="number" id="newMatPrice" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-white" placeholder="0">
                </div>
                <div class="w-16">
                    <label class="block text-xs text-gray-400 mb-1">色</label>
                    <input type="color" id="newMatColor" class="w-full h-[38px] bg-transparent cursor-pointer" value="#cccccc">
                </div>
                <button id="addMaterialBtn" class="bg-cad-accent hover:bg-blue-600 text-white px-6 py-2 rounded h-[40px] transition">
                    <i class="fas fa-plus mr-1"></i> 追加
                </button>
            </div>

            <!-- Search and Table -->
            <div class="flex-1 bg-cad-panel rounded border border-cad-border overflow-hidden flex flex-col">
                <div class="p-3 border-b border-cad-border bg-gray-800 flex items-center">
                    <div class="relative w-full max-w-sm">
                        <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                        <input type="text" id="masterSearchInput" class="w-full bg-gray-700 border border-gray-600 rounded pl-9 pr-3 py-1 text-sm text-white focus:outline-none focus:border-cad-accent" placeholder="部材名・商品名で検索...">
                    </div>
                </div>

                <div class="overflow-y-auto custom-scroll flex-1">
                    <table class="w-full master-table text-left border-collapse table-fixed">
                        <thead class="sticky top-0 z-10">
                            <tr>
                                <th class="w-12 text-center">色</th>
                                <th class="w-1/4">部材名称</th>
                                <th class="w-1/4 text-gray-400">参照商品名</th>
                                <th class="w-24">タイプ判定</th>
                                <th class="w-20 text-right">単位</th>
                                <th class="w-28 text-right">単価</th>
                                <th class="w-20 text-center">画像</th>
                                <th class="w-20 text-center">操作</th>
                            </tr>
                        </thead>
                        <tbody id="masterTableBody">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
                <div class="p-3 bg-gray-800 text-xs text-gray-400 border-t border-cad-border text-right" id="masterCount">
                    全 0 件
                </div>
            </div>
        </div>
    </div>

    <!-- Script Logic -->
    <script>
        /**
         * Database & Defaults
         */
        let db = null; // 初期値null
        const DEFAULT_PRESETS = [
            { id: 101, name: 'CB100', refName: '重量ブロック 100', unit: 'm', price: 1800, type: 'line', color: '#A9A9A9' },
            { id: 102, name: 'CB120', refName: '重量ブロック 120', unit: 'm', price: 2200, type: 'line', color: '#808080' },
            { id: 103, name: 'CB150', refName: '重量ブロック 150', unit: 'm', price: 2800, type: 'line', color: '#696969' },
            { id: 104, name: '化粧ブロックA', refName: 'ユニソン シャモティ', unit: 'm', price: 4500, type: 'line', color: '#CD853F' },
            { id: 105, name: 'ブロック基礎', refName: 'ブロック 基礎断面', unit: 'm', price: 3500, type: 'line', color: '#778899' },
            
            { id: 201, name: '土間コンクリート(金鏝)', refName: '土間コンクリート 金鏝仕上げ', unit: 'm2', price: 11000, type: 'area', color: '#D3D3D3' },
            { id: 202, name: '土間コンクリート(刷毛)', refName: '土間コンクリート 刷毛引き', unit: 'm2', price: 11000, type: 'area', color: '#C0C0C0' },
            { id: 203, name: '砕石路盤 (RC40)', refName: '砕石 RC40', unit: 'm2', price: 1500, type: 'area', color: '#708090' },
            { id: 204, name: '防草シート+砂利', refName: '防草シート 砂利敷き', unit: 'm2', price: 3500, type: 'area', color: '#F0E68C' },
            { id: 205, name: 'インターロッキング', refName: 'インターロッキング 舗装', unit: 'm2', price: 12000, type: 'area', color: '#CD5C5C' },
            
            { id: 301, name: 'メッシュフェンス T-8', refName: 'LIXIL ハイグリッドフェンスN8型', unit: 'm', price: 5000, type: 'line', color: '#4682B4' },
            { id: 302, name: '目隠しフェンス T-8', refName: 'LIXIL フェンスAB YL2型', unit: 'm', price: 12000, type: 'line', color: '#5F9EA0' },
            { id: 303, name: '機能門柱', refName: 'LIXIL 機能門柱FW', unit: '基', price: 80000, type: 'count', color: '#2F4F4F' },
            { id: 304, name: 'カーポート (1台用)', refName: 'YKKAP アリュース 1台用', unit: '基', price: 150000, type: 'count', color: '#191970' },
            
            { id: 401, name: '高木 (H2.5)', refName: 'シマトネリコ 株立ち', unit: '本', price: 25000, type: 'count', color: '#228B22' },
            { id: 402, name: '人工芝', refName: 'リアリーターフ', unit: 'm2', price: 8500, type: 'area', color: '#32CD32' }
        ];

        let loadedMaterials = [];

        const App = {
            canvas: document.getElementById('mainCanvas'),
            ctx: null,
            width: 0,
            height: 0,
            scale: 1,      
            offsetX: 0,    
            offsetY: 0,    
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0,
            currentTool: 'select', 
            drawingPoints: [],
            isPickingForSubtraction: false,
            pixelsPerMeter: 0, 
            calibrationPoints: [],
            bgImage: null, 
            shapes: [],
            manualItems: [], 
            fontSize: 14, // Default font size
            currentSettings: {
                name: '未設定',
                masterName: '', // NEW: マスタ上の名称
                refName: '',    // NEW: 参照商品名
                price: 0,
                color: '#ffffff',
                lineWidth: 2,
                multiplier: 1, 
                isSubtractive: false,
                additionalItems: [] 
            }
        };

        window.addEventListener('load', async () => {
            App.ctx = App.canvas.getContext('2d');
            resizeCanvas();
            initEvents();
            await initDB(); 
            setTool('select');
            render();
            setTimeout(() => updateMasterTable(), 100);
        });

        window.addEventListener('resize', resizeCanvas);

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            if(container.offsetParent === null) return; 
            const dpr = window.devicePixelRatio || 1;
            App.width = container.clientWidth;
            App.height = container.clientHeight;
            App.canvas.width = App.width * dpr;
            App.canvas.height = App.height * dpr;
            App.canvas.style.width = `${App.width}px`;
            App.canvas.style.height = `${App.height}px`;
            render();
        }

        // --- Helper Functions for Master Table ---
        function getTypeLabel(type) {
            if(type === 'line') return '線 (長さ)';
            if(type === 'area') return '面 (面積)';
            if(type === 'count') return '点 (個数)';
            return '不明';
        }
        function getTypeBadgeColor(type) {
            if(type === 'line') return 'bg-blue-900 text-blue-200';
            if(type === 'area') return 'bg-green-900 text-green-200';
            if(type === 'count') return 'bg-yellow-900 text-yellow-200';
            return 'bg-gray-700';
        }

        // --- IndexedDB with Fallback (Chrome Logic) ---
        function initDB() {
            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open("ExteriorPlannerDB", 2); 
                    request.onupgradeneeded = (e) => {
                        db = e.target.result;
                        if (!db.objectStoreNames.contains("materials")) {
                            const store = db.createObjectStore("materials", { keyPath: "id", autoIncrement: true });
                            // トランザクション内で初期データを投入
                            DEFAULT_PRESETS.forEach(item => {
                                // IDが競合しないように念のためidを除外して追加するか、そのまま追加
                                const { id, ...cleanItem } = item;
                                store.add(cleanItem);
                            });
                        }
                    };
                    request.onsuccess = (e) => {
                        db = e.target.result;
                        loadMaterialsFromDB().then(() => resolve());
                    };
                    request.onerror = (e) => {
                        console.warn("DB Access Error (Chrome Restricted?): Using in-memory fallback.", e);
                        useFallbackMode();
                        resolve();
                    };
                } catch(err) {
                    console.warn("IndexedDB Exception: Using in-memory fallback.", err);
                    useFallbackMode();
                    resolve();
                }
            });
        }

        function useFallbackMode() {
            db = null; // Explicitly null
            // ディープコピーで初期化
            loadedMaterials = JSON.parse(JSON.stringify(DEFAULT_PRESETS));
            const msg = document.getElementById('dbStatusMsg');
            if(msg) msg.textContent = "※ブラウザの制限により保存機能が無効化されています（編集は可能ですがリロードで消えます）";
        }

        function loadMaterialsFromDB() {
            return new Promise((resolve) => {
                if (!db) {
                    resolve(); // Fallback mode already has data
                    return;
                }
                const transaction = db.transaction(["materials"], "readonly");
                const store = transaction.objectStore("materials");
                const request = store.getAll();
                request.onsuccess = (e) => {
                    const res = e.target.result;
                    // FIX for Chrome logic: if empty but DB works, it's empty. Don't auto-restore.
                    loadedMaterials = res || [];
                    resolve();
                };
                request.onerror = () => { 
                    loadedMaterials = []; 
                    resolve(); 
                }
            });
        }

        function addMaterialToDB(material) {
            return new Promise((resolve) => {
                if(!material.type) material.type = determineTypeByUnit(material.unit);
                
                if (!db) {
                    // Fallback: Add to memory array
                    material.id = Date.now(); // Temporary ID
                    loadedMaterials.push(material);
                    updateMasterTable();
                    resolve();
                    return;
                }

                const transaction = db.transaction(["materials"], "readwrite");
                const store = transaction.objectStore("materials");
                store.add(material);
                transaction.oncomplete = () => {
                    loadMaterialsFromDB().then(() => {
                        updateMasterTable();
                        resolve();
                    });
                };
                transaction.onerror = () => {
                    // DB Error during add
                    material.id = Date.now();
                    loadedMaterials.push(material);
                    updateMasterTable();
                    resolve();
                };
            });
        }

        function determineTypeByUnit(unitStr) {
            if (!unitStr) return 'count';
            const u = String(unitStr).toLowerCase().trim();
            if (u.includes('m2') || u.includes('㎡') || u.includes('平米') || u.includes('sq')) return 'area';
            if (u.includes('m') || u.includes('ｍ') || u.includes('メートル') || u.includes('linear') || u.includes('段') || u.includes('l=')) return 'line';
            return 'count';
        }

        function deleteMaterialFromDB(id) {
            if(!confirm("削除しますか？")) return;
            
            if (!db) {
                // Fallback: Remove from memory array
                loadedMaterials = loadedMaterials.filter(m => m.id !== id);
                updateMasterTable();
                return;
            }

            const transaction = db.transaction(["materials"], "readwrite");
            const store = transaction.objectStore("materials");
            store.delete(id);
            transaction.oncomplete = () => loadMaterialsFromDB().then(() => updateMasterTable());
        }

        function deleteAllMaterials() {
            if(!confirm("【警告】マスタデータを全て削除します。\n本当によろしいですか？")) return;
            
            if (!db) {
                loadedMaterials = [];
                updateMasterTable();
                alert("全てのデータを削除しました（一時モード）。");
                return;
            }

            const transaction = db.transaction(["materials"], "readwrite");
            const store = transaction.objectStore("materials");
            store.clear();
            transaction.oncomplete = () => {
                loadMaterialsFromDB().then(() => {
                    updateMasterTable();
                    alert("全てのデータを削除しました。");
                });
            };
        }

        function restoreDefaults() {
            if(!confirm("初期データに戻しますか？（追加データは消えます）")) return;

            if (!db) {
                loadedMaterials = JSON.parse(JSON.stringify(DEFAULT_PRESETS));
                updateMasterTable();
                alert("初期データを復元しました（一時モード）。");
                return;
            }

            try {
                const transaction = db.transaction(["materials"], "readwrite");
                const store = transaction.objectStore("materials");
                store.clear().onsuccess = () => {
                    DEFAULT_PRESETS.forEach(item => {
                        const { id, ...cleanItem } = item;
                        store.add(cleanItem);
                    });
                };
                transaction.oncomplete = () => {
                    loadMaterialsFromDB().then(() => {
                        updateMasterTable();
                        alert("初期データを復元しました。");
                    });
                };
            } catch (err) { alert("エラー: " + err.message); }
        }

        function saveMaterialsToDB(materials) {
            return new Promise((resolve, reject) => {
                if (!db) {
                    // Fallback: Add to memory
                    materials.forEach(m => {
                        m.id = Date.now() + Math.random();
                        loadedMaterials.push(m);
                    });
                    updateMasterTable();
                    alert(`${materials.length}件の単価データを追加しました（一時モード）。`);
                    resolve();
                    return;
                }

                const transaction = db.transaction(["materials"], "readwrite");
                const store = transaction.objectStore("materials");
                materials.forEach(mat => store.add(mat));
                transaction.oncomplete = () => {
                    loadMaterialsFromDB().then(() => {
                        updateMasterTable();
                        alert(`${materials.length}件の単価データを追加しました。`);
                        resolve();
                    });
                };
                transaction.onerror = (e) => reject(e);
            });
        }

        // --- Event Init ---
        function initEvents() {
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', () => switchView(btn.dataset.view));
            });

            document.getElementById('addMaterialBtn').addEventListener('click', () => {
                const name = document.getElementById('newMatName').value;
                const refName = document.getElementById('newMatRef').value;
                const unit = document.getElementById('newMatUnit').value;
                const price = parseInt(document.getElementById('newMatPrice').value) || 0;
                const color = document.getElementById('newMatColor').value;
                if(!name) { alert('名称を入力してください'); return; }
                addMaterialToDB({ name, refName, unit, price, color });
                document.getElementById('newMatName').value = '';
                document.getElementById('newMatRef').value = '';
                document.getElementById('newMatUnit').value = '';
                document.getElementById('newMatPrice').value = '';
            });

            document.getElementById('deleteAllBtn').addEventListener('click', deleteAllMaterials);
            document.getElementById('restoreDefaultsBtn').addEventListener('click', restoreDefaults);
            document.getElementById('masterSearchInput').addEventListener('input', () => updateMasterTable());

            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setTool(btn.dataset.tool);
                });
            });

            App.canvas.addEventListener('mousedown', onMouseDown);
            App.canvas.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp); 
            App.canvas.addEventListener('wheel', onWheel, { passive: false });
            App.canvas.addEventListener('contextmenu', onRightClick);

            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('priceListInput').addEventListener('change', handlePriceListUpload);
            document.getElementById('showLabels').addEventListener('change', render);
            
            // Font Size Slider
            document.getElementById('globalFontSize').addEventListener('input', (e) => {
                App.fontSize = parseInt(e.target.value);
                document.getElementById('fontSizeDisplay').textContent = `${App.fontSize}px`;
                render();
            });

            document.getElementById('exportBtn').addEventListener('click', exportCSV);
            document.getElementById('saveImgBtn').addEventListener('click', saveCanvasAsImage);
            document.getElementById('savePdfBtn').addEventListener('click', saveCanvasAsPDF);
            
            document.getElementById('presetSelect').addEventListener('change', applyPreset);
            document.getElementById('itemName').addEventListener('input', (e) => App.currentSettings.name = e.target.value);
            document.getElementById('itemColor').addEventListener('input', (e) => App.currentSettings.color = e.target.value);
            document.getElementById('lineWidth').addEventListener('input', (e) => App.currentSettings.lineWidth = parseInt(e.target.value));
            document.getElementById('itemMultiplier').addEventListener('input', (e) => App.currentSettings.multiplier = parseFloat(e.target.value) || 1);
            document.getElementById('isSubtractive').addEventListener('change', (e) => App.currentSettings.isSubtractive = e.target.checked);
            
            document.getElementById('rotateLeftBtn').addEventListener('click', () => rotateImage(-90));
            document.getElementById('rotateRightBtn').addEventListener('click', () => rotateImage(90));
            document.getElementById('pickSubtractBtn').addEventListener('click', () => {
                App.isPickingForSubtraction = true;
                document.getElementById('pickStatus').classList.remove('hidden');
                document.body.style.cursor = 'crosshair';
            });
            document.getElementById('additionalItemSelect').addEventListener('change', addAdditionalItem);

            // --- NEW: Manual Item Event ---
            document.getElementById('addManualItemBtn').addEventListener('click', addManualItem);
            
            // Enter key support for manual items
            const handleManualEnter = (e) => {
                if (e.key === 'Enter') addManualItem();
            };
            document.getElementById('manualItemName').addEventListener('keypress', handleManualEnter);
            document.getElementById('manualItemPrice').addEventListener('keypress', handleManualEnter);
        }

        // --- Core Functions ---
        function switchView(viewName) {
            const plannerView = document.getElementById('view-planner');
            const masterView = document.getElementById('view-master');
            const plannerActions = document.getElementById('plannerActions');
            const navs = document.querySelectorAll('.nav-btn');
            navs.forEach(btn => {
                if(btn.dataset.view === viewName) btn.classList.add('active');
                else btn.classList.remove('active');
            });
            if (viewName === 'planner') {
                plannerView.classList.remove('hidden');
                masterView.classList.add('hidden');
                masterView.classList.remove('flex');
                plannerActions.classList.remove('hidden');
                resizeCanvas();
                if(['line','area','count'].includes(App.currentTool)) populatePresets(App.currentTool);
            } else {
                plannerView.classList.add('hidden');
                masterView.classList.remove('hidden');
                masterView.classList.add('flex');
                plannerActions.classList.add('hidden');
                updateMasterTable();
            }
        }

        function updateMasterTable() {
            const tbody = document.getElementById('masterTableBody');
            const searchInput = document.getElementById('masterSearchInput');
            const filterTerm = searchInput ? searchInput.value.toLowerCase() : '';
            tbody.innerHTML = '';
            const filteredMaterials = loadedMaterials.filter(mat => {
                const searchStr = (mat.name + (mat.refName || '')).toLowerCase();
                return !filterTerm || searchStr.includes(filterTerm);
            });
            filteredMaterials.forEach(mat => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="text-center"><span class="inline-block w-6 h-6 rounded border border-gray-600" style="background-color: ${mat.color || '#fff'}"></span></td>
                    <td class="font-bold text-white truncate" title="${mat.name}">${mat.name}</td>
                    <td class="text-gray-400 text-sm truncate" title="${mat.refName || ''}">${mat.refName || ''}</td>
                    <td><span class="px-2 py-1 rounded text-xs ${getTypeBadgeColor(mat.type)}">${getTypeLabel(mat.type)}</span></td>
                    <td class="text-right text-mono text-gray-400">${mat.unit}</td>
                    <td class="text-right text-mono font-bold">¥${mat.price.toLocaleString()}</td>
                    <td class="text-center"><button class="bg-blue-600 hover:bg-blue-500 text-white rounded p-1.5 w-8 h-8 flex items-center justify-center mx-auto transition" onclick="searchMaterialImage('${mat.refName || mat.name}')"><i class="fas fa-images"></i></button></td>
                    <td class="text-center"><button class="text-red-500 hover:text-red-300 p-1" onclick="deleteMaterialFromDB(${mat.id})"><i class="fas fa-trash"></i></button></td>
                `;
                tbody.appendChild(tr);
            });
            document.getElementById('masterCount').textContent = `全 ${filteredMaterials.length} 件`;
        }

        // --- Canvas/Tools Logic ---
        function setTool(toolName) {
            App.currentTool = toolName;
            App.drawingPoints = [];
            App.calibrationPoints = [];
            App.isPickingForSubtraction = false;
            document.getElementById('pickStatus').classList.add('hidden');
            document.body.style.cursor = 'default';
            const materialSettings = document.getElementById('materialSettings');
            const toolMessage = document.getElementById('toolMessage');
            const subtractiveOption = document.getElementById('subtractiveOption');
            subtractiveOption.classList.add('hidden');
            App.currentSettings.isSubtractive = false;
            App.currentSettings.additionalItems = [];
            document.getElementById('isSubtractive').checked = false;
            updateAdditionalItemsList();

            if (toolName === 'select' || toolName === 'scale') {
                materialSettings.classList.add('hidden');
                toolMessage.classList.remove('hidden');
                if (toolName === 'scale') toolMessage.textContent = '図面上の既知の2点をクリックしてスケールを設定してください';
                else toolMessage.textContent = '図面をドラッグして移動、ホイールでズーム、Deleteキーで最後の操作を取り消し';
            } else {
                materialSettings.classList.remove('hidden');
                toolMessage.classList.add('hidden');
                populatePresets(toolName);
                if (toolName === 'area') subtractiveOption.classList.remove('hidden');
            }
        }

        function populatePresets(toolType) {
            const select = document.getElementById('presetSelect');
            const addSelect = document.getElementById('additionalItemSelect');
            select.innerHTML = '<option value="">-- 部材を選択 --</option>';
            addSelect.innerHTML = '<option value="">+ 追加する部材を選択...</option>';
            const filtered = loadedMaterials.filter(m => {
                if (toolType === 'line') return m.type === 'line' || m.unit === 'm' || m.unit === 'ｍ';
                if (toolType === 'area') return m.type === 'area' || m.unit.includes('m2') || m.unit.includes('㎡');
                if (toolType === 'count') return m.type === 'count' && !String(m.unit).match(/[mｍＭＬLHW]/i);
                return true;
            });
            loadedMaterials.forEach(m => {
                 const opt = document.createElement('option');
                 opt.value = JSON.stringify(m);
                 opt.textContent = `${m.name} (${m.unit})`;
                 addSelect.appendChild(opt);
            });
            filtered.forEach((p, idx) => {
                const opt = document.createElement('option');
                opt.value = JSON.stringify(p);
                opt.textContent = `${p.name} (${p.unit})`;
                select.appendChild(opt);
            });
        }

        function applyPreset() {
            const val = document.getElementById('presetSelect').value;
            if (!val) return;
            const preset = JSON.parse(val);
            document.getElementById('itemName').value = preset.name;
            document.getElementById('itemPrice').value = preset.price;
            
            // Set properties
            App.currentSettings.name = preset.name;
            App.currentSettings.masterName = preset.name; // Keep master name
            App.currentSettings.refName = preset.refName || ''; // Keep ref name
            App.currentSettings.price = preset.price;
            App.currentSettings.multiplier = 1;
            document.getElementById('itemMultiplier').value = 1;

            if (preset.color) {
                document.getElementById('itemColor').value = preset.color;
                App.currentSettings.color = preset.color;
            }
        }

        function addAdditionalItem() {
            const val = document.getElementById('additionalItemSelect').value;
            if (!val) return;
            const item = JSON.parse(val);
            App.currentSettings.additionalItems.push({ name: item.name, price: item.price, unit: item.unit });
            document.getElementById('additionalItemSelect').value = "";
            updateAdditionalItemsList();
        }

        function removeAdditionalItem(index) {
            App.currentSettings.additionalItems.splice(index, 1);
            updateAdditionalItemsList();
        }

        function updateAdditionalItemsList() {
            const container = document.getElementById('additionalItemsList');
            container.innerHTML = '';
            App.currentSettings.additionalItems.forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-gray-700 px-2 py-1 rounded text-xs text-blue-200 border border-blue-900';
                div.innerHTML = `<span>+ ${item.name}</span><button onclick="removeAdditionalItem(${idx})" class="text-red-400 hover:text-white ml-2">×</button>`;
                container.appendChild(div);
            });
        }

        // --- File/Image ---
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('loader').style.display = 'flex';
            try {
                if (file.type === 'application/pdf') {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    const page = await pdf.getPage(1);
                    // Increased scale to 5.0 for better resolution
                    const viewport = page.getViewport({ scale: 5.0 }); 
                    const cvs = document.createElement('canvas');
                    cvs.width = viewport.width;
                    cvs.height = viewport.height;
                    const ctx = cvs.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                    App.bgImage = cvs;
                } else {
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => { App.bgImage = img; resolve(); };
                        img.src = URL.createObjectURL(file);
                    });
                }
                fitToScreen();
                App.pixelsPerMeter = 0;
                document.getElementById('scaleStatus').textContent = "未設定";
                document.getElementById('scaleStatus').classList.remove('text-green-500');
                document.getElementById('scaleStatus').classList.add('text-yellow-500');
            } catch (err) {
                console.error(err);
                alert("ファイルの読み込みに失敗しました。");
            } finally {
                document.getElementById('loader').style.display = 'none';
                render();
            }
        }

        function handlePriceListUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const data = new Uint8Array(evt.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                const newMaterials = [];
                let startIndex = 0;
                if(typeof jsonData[0][3] !== 'number') startIndex = 1; 
                for (let i = startIndex; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (!row[0]) continue;
                    const name = row[0];
                    const refName = row[1] ? String(row[1]).trim() : '';
                    const unit = row[2] ? String(row[2]).trim() : '';
                    const price = parseInt(row[3]) || 0;
                    const type = determineTypeByUnit(unit);
                    newMaterials.push({ name, refName, unit, price, type, color: getRandomColor() });
                }
                if (newMaterials.length > 0) saveMaterialsToDB(newMaterials);
                else alert("有効なデータが見つかりませんでした。");
                e.target.value = '';
            };
            reader.readAsArrayBuffer(file);
        }

        function rotateImage(deg) {
            if (!App.bgImage) { alert("図面が読み込まれていません"); return; }
            if (App.shapes.length > 0 && !confirm("図面を回転させると位置がずれます。続行しますか？")) return;
            const canvas = document.createElement('canvas');
            canvas.width = App.bgImage.height;
            canvas.height = App.bgImage.width;
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(deg * Math.PI / 180);
            ctx.drawImage(App.bgImage, -App.bgImage.width / 2, -App.bgImage.height / 2);
            const newImg = new Image();
            newImg.onload = () => { App.bgImage = newImg; fitToScreen(); render(); };
            newImg.src = canvas.toDataURL();
        }

        // --- Interaction ---
        function fitToScreen() {
            if (!App.bgImage) return;
            const aspectCanvas = App.width / App.height;
            const aspectImg = App.bgImage.width / App.bgImage.height;
            if (aspectImg > aspectCanvas) App.scale = (App.width * 0.9) / App.bgImage.width;
            else App.scale = (App.height * 0.9) / App.bgImage.height;
            App.offsetX = (App.width - App.bgImage.width * App.scale) / 2;
            App.offsetY = (App.height - App.bgImage.height * App.scale) / 2;
        }

        function screenToWorld(sx, sy) {
            return { x: (sx - App.offsetX) / App.scale, y: (sy - App.offsetY) / App.scale };
        }
        function worldToScreen(wx, wy) {
            return { x: wx * App.scale + App.offsetX, y: wy * App.scale + App.offsetY };
        }
        
        function findShapeAt(worldX, worldY) {
            for (let i = App.shapes.length - 1; i >= 0; i--) {
                const shape = App.shapes[i];
                if (shape.type === 'area') {
                    if (isPointInPolygon({x: worldX, y: worldY}, shape.points)) return shape;
                }
            }
            return null;
        }

        function isPointInPolygon(p, polygon) {
            let isInside = false;
            let minX = polygon[0].x, maxX = polygon[0].x;
            let minY = polygon[0].y, maxY = polygon[0].y;
            for (let n = 1; n < polygon.length; n++) {
                const q = polygon[n];
                minX = Math.min(q.x, minX); maxX = Math.max(q.x, maxX);
                minY = Math.min(q.y, minY); maxY = Math.max(q.y, maxY);
            }
            if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) return false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&
                        (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    isInside = !isInside;
                }
            }
            return isInside;
        }

        function onMouseDown(e) {
            if (e.button === 1) { 
                App.isDragging = true;
                App.lastMouseX = e.clientX;
                App.lastMouseY = e.clientY;
                return;
            }
            const rect = App.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPos = screenToWorld(mouseX, mouseY);

            if (e.button === 0) { 
                if (App.isPickingForSubtraction) {
                    const found = findShapeAt(worldPos.x, worldPos.y);
                    if (found) {
                        const newShape = {
                            type: 'area',
                            points: JSON.parse(JSON.stringify(found.points)), 
                            settings: { ...App.currentSettings, isSubtractive: true }, 
                            id: Date.now()
                        };
                        App.shapes.push(newShape);
                        updateEstimation();
                        App.isPickingForSubtraction = false;
                        document.getElementById('pickStatus').classList.add('hidden');
                        document.body.style.cursor = 'default';
                        render();
                    } else { alert("図形が見つかりません。"); }
                    return;
                }
                if (App.currentTool === 'select') {
                    App.isDragging = true;
                    App.lastMouseX = e.clientX;
                    App.lastMouseY = e.clientY;
                } else if (App.currentTool === 'scale') {
                    App.calibrationPoints.push(worldPos);
                    if (App.calibrationPoints.length === 2) finalizeCalibration();
                } else if (App.currentTool === 'count') {
                    addShape('count', [worldPos]);
                } else if (App.currentTool === 'line' || App.currentTool === 'area') {
                    App.drawingPoints.push(worldPos);
                }
            }
            render();
        }

        function onMouseMove(e) {
            const rect = App.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPos = screenToWorld(mouseX, mouseY);
            document.getElementById('cursorPos').textContent = `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)}`;

            if (App.isDragging) {
                const dx = e.clientX - App.lastMouseX;
                const dy = e.clientY - App.lastMouseY;
                App.offsetX += dx;
                App.offsetY += dy;
                App.lastMouseX = e.clientX;
                App.lastMouseY = e.clientY;
                render();
            } else {
                render(worldPos); 
            }
        }

        function onMouseUp(e) {
            App.isDragging = false;
        }

        function onWheel(e) {
            e.preventDefault();
            const rect = App.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);
            const worldPosBefore = screenToWorld(mouseX, mouseY);
            App.scale *= zoom;
            App.scale = Math.max(0.01, Math.min(App.scale, 50)); 
            const worldPosAfter = screenToWorld(mouseX, mouseY);
            App.offsetX += (worldPosAfter.x - worldPosBefore.x) * App.scale;
            App.offsetY += (worldPosAfter.y - worldPosBefore.y) * App.scale;
            render();
        }

        function onRightClick(e) {
            e.preventDefault();
            if (App.isPickingForSubtraction) {
                App.isPickingForSubtraction = false;
                document.getElementById('pickStatus').classList.add('hidden');
                document.body.style.cursor = 'default';
            } else if (App.currentTool === 'line' && App.drawingPoints.length > 1) {
                addShape('line', [...App.drawingPoints]);
                App.drawingPoints = [];
            } else if (App.currentTool === 'area' && App.drawingPoints.length > 2) {
                addShape('area', [...App.drawingPoints]);
                App.drawingPoints = [];
            } else {
                App.drawingPoints = [];
                App.calibrationPoints = [];
            }
            render();
        }

        function finalizeCalibration() {
            const p1 = App.calibrationPoints[0];
            const p2 = App.calibrationPoints[1];
            const pixelDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const meterInput = prompt("指定した2点間の距離(メートル)を入力してください", "1.0");
            const meters = parseFloat(meterInput);
            if (meters && meters > 0) {
                App.pixelsPerMeter = pixelDist / meters;
                document.getElementById('scaleStatus').textContent = `1m = ${Math.round(App.pixelsPerMeter)}px`;
                document.getElementById('scaleStatus').classList.remove('text-yellow-500');
                document.getElementById('scaleStatus').classList.add('text-green-500');
            }
            App.calibrationPoints = [];
            render();
        }

        function addShape(type, points) {
            const settings = JSON.parse(JSON.stringify(App.currentSettings));
            // Ensure masterName is populated even if not from preset
            if (!settings.masterName) settings.masterName = settings.name;
            const shape = { type, points, settings, id: Date.now() + Math.random() };
            App.shapes.push(shape);
            updateEstimation();
        }

        function deleteShape(shapeId) {
            App.shapes = App.shapes.filter(s => s.id !== shapeId);
            updateEstimation();
            render();
        }

        // --- Render ---
        function render(cursorWorldPos = null) {
            const ctx = App.ctx;
            if (App.width === 0 || App.height === 0) return;
            // Clear handling dpr
            const dpr = window.devicePixelRatio || 1;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Scale the context
            ctx.clearRect(0, 0, App.width, App.height);
            
            if (App.bgImage) {
                ctx.save();
                ctx.translate(App.offsetX, App.offsetY);
                ctx.scale(App.scale, App.scale);
                ctx.drawImage(App.bgImage, 0, 0);
                
                // Export Font Size Scaling (approx 2x for high res export)
                const exportFontSize = (App.fontSize || 14) * 2;
                ctx.restore();
            }
            App.shapes.forEach(shape => drawShape(ctx, shape));
            const color = App.currentSettings.color;
            const lw = App.currentSettings.lineWidth;
            if (App.currentTool === 'scale') {
                App.calibrationPoints.forEach(p => drawMarker(ctx, p, '#ff00ff'));
                if (App.calibrationPoints.length === 1 && cursorWorldPos) {
                    drawLine(ctx, App.calibrationPoints[0], cursorWorldPos, '#ff00ff', true, 2);
                }
            } else if (App.drawingPoints.length > 0) {
                App.drawingPoints.forEach(p => drawMarker(ctx, p, color, 3));
                if (App.drawingPoints.length > 0 && cursorWorldPos) {
                     drawLine(ctx, App.drawingPoints[App.drawingPoints.length-1], cursorWorldPos, color, true, lw);
                }
                for (let i = 0; i < App.drawingPoints.length - 1; i++) {
                    drawLine(ctx, App.drawingPoints[i], App.drawingPoints[i+1], color, false, lw);
                }
                if (App.currentTool === 'area' && App.drawingPoints.length > 1 && cursorWorldPos) {
                    ctx.save();
                    ctx.beginPath();
                    const sStart = worldToScreen(App.drawingPoints[0].x, App.drawingPoints[0].y);
                    ctx.moveTo(sStart.x, sStart.y);
                    for(let i=1; i<App.drawingPoints.length; i++) {
                        const s = worldToScreen(App.drawingPoints[i].x, App.drawingPoints[i].y);
                        ctx.lineTo(s.x, s.y);
                    }
                    const sCursor = worldToScreen(cursorWorldPos.x, cursorWorldPos.y);
                    ctx.lineTo(sCursor.x, sCursor.y);
                    ctx.fillStyle = hexToRgba(color, 0.2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawShape(ctx, shape) {
            const color = shape.settings.color;
            const isSub = shape.settings.isSubtractive;
            const lw = shape.settings.lineWidth || 2;
            const showLabel = document.getElementById('showLabels').checked;
            
            if (shape.type === 'count') {
                drawMarker(ctx, shape.points[0], color, 4 + lw, true);
            } else if (shape.type === 'line') {
                for (let i = 0; i < shape.points.length - 1; i++) {
                    drawLine(ctx, shape.points[i], shape.points[i+1], color, false, lw);
                }
                shape.points.forEach(p => drawMarker(ctx, p, color, lw));
            } else if (shape.type === 'area') {
                ctx.save();
                ctx.beginPath();
                const start = worldToScreen(shape.points[0].x, shape.points[0].y);
                ctx.moveTo(start.x, start.y);
                for (let i = 1; i < shape.points.length; i++) {
                    const p = worldToScreen(shape.points[i].x, shape.points[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.closePath();
                if (isSub) {
                    ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                    ctx.strokeStyle = "#ff0000";
                    ctx.setLineDash([5, 5]);
                } else {
                    ctx.fillStyle = hexToRgba(color, 0.3);
                    ctx.strokeStyle = color;
                    ctx.setLineDash([]);
                }
                ctx.lineWidth = lw;
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
            if (showLabel && shape.points.length > 0) {
                const val = calculateMetric(shape);
                let text = `${shape.settings.name}`;
                const mult = shape.settings.multiplier || 1;
                if (shape.type === 'line') text += ` L=${val.toFixed(1)}m`;
                else if (shape.type === 'area') text += ` ${Math.abs(val).toFixed(1)}㎡`;
                if (mult > 1) text += ` x${mult}`;
                if (shape.settings.additionalItems && shape.settings.additionalItems.length > 0) {
                    text += ` (+${shape.settings.additionalItems.length})`;
                }
                let pos = shape.points[0];
                if (shape.type === 'area') {
                    let sx=0, sy=0;
                    shape.points.forEach(p => { sx+=p.x; sy+=p.y; });
                    pos = {x: sx/shape.points.length, y: sy/shape.points.length};
                } else if (shape.type === 'line') {
                    pos = shape.points[Math.floor(shape.points.length/2)];
                }
                drawLabel(ctx, pos, text, color);
            }
        }

        function drawLine(ctx, p1, p2, color, dashed, width) {
            const s1 = worldToScreen(p1.x, p1.y);
            const s2 = worldToScreen(p2.x, p2.y);
            ctx.beginPath();
            ctx.moveTo(s1.x, s1.y);
            ctx.lineTo(s2.x, s2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (dashed) ctx.setLineDash([5, 5]);
            else ctx.setLineDash([]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawMarker(ctx, p, color, size, isIcon = false) {
            const s = worldToScreen(p.x, p.y);
            ctx.fillStyle = color;
            if (isIcon) {
                ctx.beginPath();
                ctx.arc(s.x, s.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                ctx.fillRect(s.x - size/2, s.y - size/2, size, size);
            }
        }
        
        function drawLabel(ctx, p, text, color) {
            const s = worldToScreen(p.x, p.y);
            const fontSize = App.fontSize || 14;
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.fillStyle = color; 
            ctx.fillText(text, s.x + 8, s.y);
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function createExportCanvas() {
            if (!App.bgImage) {
                alert("図面が読み込まれていません");
                return null;
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = App.bgImage.width;
            tempCanvas.height = App.bgImage.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(App.bgImage, 0, 0);
            
            const exportFontSize = (App.fontSize || 14) * 2;

            App.shapes.forEach(shape => {
                const color = shape.settings.color;
                const isSub = shape.settings.isSubtractive;
                const lw = (shape.settings.lineWidth || 2) * 2; 
                
                if (shape.type === 'count') {
                    const p = shape.points[0];
                    tCtx.fillStyle = color;
                    tCtx.beginPath();
                    tCtx.arc(p.x, p.y, (4 + (shape.settings.lineWidth||2))*2, 0, Math.PI * 2);
                    tCtx.fill();
                    tCtx.strokeStyle = "#fff";
                    tCtx.lineWidth = 2;
                    tCtx.stroke();
                } else if (shape.type === 'line') {
                    for (let i = 0; i < shape.points.length - 1; i++) {
                        const p1 = shape.points[i];
                        const p2 = shape.points[i+1];
                        tCtx.beginPath();
                        tCtx.moveTo(p1.x, p1.y);
                        tCtx.lineTo(p2.x, p2.y);
                        tCtx.strokeStyle = color;
                        tCtx.lineWidth = lw;
                        tCtx.stroke();
                    }
                    shape.points.forEach(p => {
                        tCtx.fillStyle = color;
                        tCtx.fillRect(p.x - lw, p.y - lw, lw*2, lw*2);
                    });
                } else if (shape.type === 'area') {
                    tCtx.save();
                    tCtx.beginPath();
                    tCtx.moveTo(shape.points[0].x, shape.points[0].y);
                    for (let i = 1; i < shape.points.length; i++) {
                        tCtx.lineTo(shape.points[i].x, shape.points[i].y);
                    }
                    tCtx.closePath();
                    if (isSub) {
                        tCtx.fillStyle = "rgba(255, 0, 0, 0.3)";
                        tCtx.strokeStyle = "#ff0000";
                        tCtx.setLineDash([10, 10]);
                    } else {
                        tCtx.fillStyle = hexToRgba(color, 0.3);
                        tCtx.strokeStyle = color;
                    }
                    tCtx.lineWidth = lw;
                    tCtx.fill();
                    tCtx.stroke();
                    tCtx.restore();
                }
                if(document.getElementById('showLabels').checked && shape.points.length > 0) {
                    const val = calculateMetric(shape);
                    let text = `${shape.settings.name}`;
                    const mult = shape.settings.multiplier || 1;
                    if (shape.type === 'line') text += ` L=${val.toFixed(1)}m`;
                    else if (shape.type === 'area') text += ` ${Math.abs(val).toFixed(1)}㎡`;
                    if (mult > 1) text += ` x${mult}`;
                    let pos = shape.points[0];
                    if (shape.type === 'area') {
                        let sx=0, sy=0;
                        shape.points.forEach(p => { sx+=p.x; sy+=p.y; });
                        pos = {x: sx/shape.points.length, y: sy/shape.points.length};
                    } else if (shape.type === 'line') {
                        pos = shape.points[Math.floor(shape.points.length/2)];
                    }
                    
                    tCtx.font = `bold ${exportFontSize}px sans-serif`; 
                    tCtx.fillStyle = color; 
                    tCtx.fillText(text, pos.x + 10, pos.y);
                }
            });
            return tempCanvas;
        }

        function saveCanvasAsImage() {
            const canvas = createExportCanvas();
            if(!canvas) return;
            const link = document.createElement('a');
            link.download = 'exterior_plan.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function saveCanvasAsPDF() {
            const canvas = createExportCanvas();
            if(!canvas) return;
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            const { jsPDF } = window.jspdf;
            const orientation = canvas.width > canvas.height ? 'l' : 'p';
            const pdf = new jsPDF({
                orientation: orientation,
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            pdf.addImage(imgData, 'JPEG', 0, 0, canvas.width, canvas.height);
            pdf.save('exterior_plan.pdf');
        }

        function calculateMetric(shape) {
            if (App.pixelsPerMeter === 0) return 0;
            if (shape.type === 'line') {
                let distPx = 0;
                for (let i = 0; i < shape.points.length - 1; i++) {
                    const p1 = shape.points[i];
                    const p2 = shape.points[i+1];
                    distPx += Math.hypot(p2.x - p1.x, p2.y - p1.y);
                }
                return distPx / App.pixelsPerMeter; 
            } 
            else if (shape.type === 'area') {
                let areaPx = 0;
                const pts = shape.points;
                const n = pts.length;
                for (let i = 0; i < n; i++) {
                    areaPx += (pts[i].x * pts[(i + 1) % n].y) - (pts[(i + 1) % n].x * pts[i].y);
                }
                areaPx = Math.abs(areaPx) / 2;
                const m2 = areaPx / (App.pixelsPerMeter * App.pixelsPerMeter);
                return shape.settings.isSubtractive ? -m2 : m2;
            }
            return 1;
        }

        // --- Manual Item Functions ---
        function addManualItem() {
            const nameInput = document.getElementById('manualItemName');
            const priceInput = document.getElementById('manualItemPrice');
            const name = nameInput.value.trim();
            const price = parseInt(priceInput.value);

            if (!name) {
                alert('項目名を入力してください');
                return;
            }
            if (isNaN(price)) {
                alert('金額を数値で入力してください');
                return;
            }

            App.manualItems.push({
                id: Date.now(),
                name: name,
                price: price
            });

            nameInput.value = '';
            priceInput.value = '';
            updateEstimation(); // 再計算と描画
            
            // Focus back on name input for rapid entry
            nameInput.focus();
        }

        function deleteManualItem(id) {
            App.manualItems = App.manualItems.filter(item => item.id !== id);
            updateEstimation();
        }

        function renderManualList() {
            const container = document.getElementById('manualItemList');
            container.innerHTML = '';
            
            App.manualItems.forEach(item => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-gray-700 px-2 py-1 rounded text-xs text-gray-200 border border-gray-600 hover:bg-gray-600 transition';
                div.innerHTML = `
                    <div class="flex-1 truncate mr-2">
                        <span class="font-bold text-yellow-100">${item.name}</span>
                    </div>
                    <div class="flex items-center gap-3">
                        <span class="font-mono">¥${item.price.toLocaleString()}</span>
                        <button onclick="deleteManualItem(${item.id})" class="text-red-400 hover:text-red-200 transition">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function updateEstimation() {
            const list = document.getElementById('estimationList');
            list.innerHTML = '';
            
            let grandTotal = 0;
            const groups = {};

            // 既存の自動積算ロジック
            App.shapes.forEach(shape => {
                const name = shape.settings.name;
                const mult = Math.round(shape.settings.multiplier || 1);
                const groupKey = `${name}_${mult}`;
                
                if (!groups[groupKey]) {
                    let displayName = name;
                    if(mult > 1) displayName += ` (x${mult})`;
                    groups[groupKey] = { 
                        name: displayName, 
                        effectivePrice: shape.settings.price * mult,
                        color: shape.settings.color,
                        quantity: 0,
                        unit: '',
                        items: []
                    };
                }
                
                const rawVal = calculateMetric(shape);
                groups[groupKey].quantity += rawVal;
                groups[groupKey].items.push({ id: shape.id, val: rawVal, mult: mult });

                if (shape.type === 'line') groups[groupKey].unit = 'm';
                else if (shape.type === 'area') groups[groupKey].unit = '㎡';
                else groups[groupKey].unit = '個';

                if (shape.settings.additionalItems) {
                    shape.settings.additionalItems.forEach(addItem => {
                        const addKey = `_ADD_${addItem.name}`;
                        if (!groups[addKey]) {
                            groups[addKey] = {
                                name: `${addItem.name} (同時計測)`,
                                effectivePrice: addItem.price, 
                                color: '#aaaaff', 
                                quantity: 0,
                                unit: addItem.unit,
                                items: []
                            };
                        }
                        groups[addKey].quantity += rawVal;
                        groups[addKey].items.push({ id: shape.id, val: rawVal, mult: 1, isChild: true });
                    });
                }
            });

            // 自動積算リストの描画
            Object.keys(groups).forEach((key, groupIndex) => {
                const item = groups[key];
                const subtotal = Math.round(item.quantity * item.effectivePrice);
                grandTotal += subtotal;

                const wrapper = document.createElement('div');
                wrapper.className = 'mb-2';
                
                const header = document.createElement('div');
                header.className = 'bg-gray-700 p-2 rounded cursor-pointer border-l-4 hover:bg-gray-600 transition';
                header.style.borderLeftColor = item.color;
                header.innerHTML = `
                    <div class="flex justify-between font-bold text-gray-200 pointer-events-none">
                        <span>${item.name}</span>
                        <span>¥${subtotal.toLocaleString()}</span>
                    </div>
                    <div class="flex justify-between text-xs text-gray-400 mt-1 pointer-events-none">
                        <span>単価: ¥${item.effectivePrice.toLocaleString()}</span>
                        <span>計: ${item.quantity.toFixed(2)} ${item.unit}</span>
                    </div>
                `;
                header.onclick = () => {
                    const content = document.getElementById(`acc-${groupIndex}`);
                    content.classList.toggle('open');
                };

                const details = document.createElement('div');
                details.id = `acc-${groupIndex}`;
                details.className = 'accordion-content bg-gray-800 rounded-b';
                
                let detailsHtml = '<div class="p-2 space-y-1">';
                item.items.forEach((subItem, idx) => {
                    if(subItem.isChild) {
                        detailsHtml += `<div class="text-xs text-gray-500 pl-2">親ID:${subItem.id} に連動</div>`;
                        return; 
                    }
                    const isMinus = subItem.val < 0;
                    let desc = isMinus ? '中抜き' : `No.${idx+1}`;
                    detailsHtml += `
                        <div class="flex justify-between items-center text-xs text-gray-400 border-b border-gray-700 pb-1">
                            <span class="${isMinus ? 'text-red-400' : ''}">
                                ${desc}: ${subItem.val.toFixed(2)}${item.unit}
                            </span>
                            <button onclick="deleteShape(${subItem.id})" class="text-red-500 hover:text-red-300 px-2">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
                details.innerHTML = detailsHtml;
                wrapper.appendChild(header);
                wrapper.appendChild(details);
                list.appendChild(wrapper);
            });

            // 手入力項目の計算とリスト更新
            renderManualList();
            let manualTotal = 0;
            App.manualItems.forEach(item => {
                manualTotal += item.price;
            });
            grandTotal += manualTotal;

            document.getElementById('totalAmount').textContent = `¥${grandTotal.toLocaleString()}`;
        }
        
        window.deleteShape = deleteShape;
        window.removeAdditionalItem = removeAdditionalItem;
        window.deleteManualItem = deleteManualItem; // グローバルスコープへ公開

        function exportCSV() {
            if (App.shapes.length === 0 && App.manualItems.length === 0) {
                alert("出力するデータがありません");
                return;
            }
            
            const includeDetails = document.getElementById('csvIncludeDetails').checked;
            const groups = {};
            
            // 図形データの集計
            App.shapes.forEach(shape => {
                const name = shape.settings.name;
                const masterName = shape.settings.masterName || name;
                const refName = shape.settings.refName || '';
                const mult = Math.round(shape.settings.multiplier || 1);
                const rawVal = calculateMetric(shape);
                
                // Group Key uses name and mult (visible identity)
                const groupKey = `${name}_${mult}`;
                
                if (!groups[groupKey]) {
                    let displayName = name;
                    if(mult > 1) displayName += ` (x${mult})`;
                    groups[groupKey] = { 
                        name: displayName, 
                        masterName: masterName, // Store master name
                        refName: refName,       // Store ref name
                        effectivePrice: shape.settings.price * mult, 
                        quantity: 0, 
                        unit: '',
                        details: [] 
                    };
                }
                
                groups[groupKey].quantity += rawVal;
                // Add details
                if (includeDetails) {
                    const isMinus = rawVal < 0;
                    const valStr = Math.abs(rawVal).toFixed(2);
                    groups[groupKey].details.push(isMinus ? `除外:${valStr}` : valStr);
                }

                if (shape.type === 'line') groups[groupKey].unit = 'm';
                else if (shape.type === 'area') groups[groupKey].unit = 'm2';
                else groups[groupKey].unit = '個';

                if (shape.settings.additionalItems) {
                    shape.settings.additionalItems.forEach(addItem => {
                        const addKey = `_ADD_${addItem.name}`;
                        if (!groups[addKey]) {
                            groups[addKey] = { 
                                name: `${addItem.name} (同時計測)`, 
                                masterName: addItem.name, // Assume item name as master for additives
                                refName: '',
                                effectivePrice: addItem.price, 
                                quantity: 0, 
                                unit: addItem.unit,
                                details: []
                            };
                        }
                        groups[addKey].quantity += rawVal;
                    });
                }
            });

            let csvContent = "data:text/csv;charset=utf-8,\uFEFF";
            
            // CSV Header with new columns
            let header = "部材名称(マスタ),表示名称,単価,数量,単位,合計金額,参照商品名";
            if (includeDetails) header += ",詳細内訳";
            csvContent += header + "\n";
            
            // 図形分出力
            Object.keys(groups).forEach(key => {
                const item = groups[key];
                const total = Math.round(item.quantity * item.effectivePrice);
                
                let row = `"${item.masterName}","${item.name}",${item.effectivePrice},${item.quantity.toFixed(2)},"${item.unit}",${total},"${item.refName}"`;
                
                if (includeDetails) {
                    row += `,"${item.details.join(' + ')}"`;
                }
                csvContent += row + "\n";
            });

            // 手入力分出力
            App.manualItems.forEach(item => {
                // A列:名称, B列:名称, G列:空, 詳細:空
                let row = `"${item.name}","${item.name} (手入力)",${item.price},1,"式",${item.price},""`;
                if (includeDetails) row += `,""`;
                csvContent += row + "\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "estimation_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getRandomColor() {
            const letters = '456789ABC';
            let color = '#';
            for (let i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * letters.length)];
            return color;
        }
    </script>
</body>
</html>